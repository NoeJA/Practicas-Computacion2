# -*- coding: utf-8 -*-
"""Practica3

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1HODNHagUCEOJDM85XFX8X0ffO-zttLv1
"""

from sympy.abc import x, y
from sympy import *
import time
import numpy as np
import time
x,y=symbols("x y")
import matplotlib.pyplot as plt


class NumericalMethods:

    def bisectionMethod(self, a, b, tol, func):

        if func.subs(x,a) * func.subs(x,b) < 0:
            print("Existe un cambio de signo")
        else: 
            print("No existen raices reales en el intervalo")
            exit(0) 
        error = 3
        c = (a + b) /2
        while(True):
            if  (b-a)<tol:
              return c
            elif float(func.subs(x,a))*float(func.subs(x,c)) > 0:
              a=c
            else:
              b=c
            c = (a + b)/2
        
    
    def Newton(self,x0, maxIt,fun):
      n=0
      while n<=maxIt:
        b=float(fun.subs(x,x0))/float(diff(fun).subs(x,x0))
        x1=x0-b
        x0=x1
        n+=1
      return x0

    def Secante(self,fun,a,b,tol=0.001):
      i=0
      fa = fun.subs(x,a)
      fb = fun.subs(x,b)
      c = b - ((b - a) / (fb - fa))*fb
      while abs(b-a)>tol:
        b=a
        a=c
        fa = fun.subs(x,a)
        fb = fun.subs(x,b)
        c = b - ((b - a) / (fb - fa))*fb
        i+=1
      return c

    def brentDekkerMethod(self,a, b, func, tol=0.0001, maxIter=50):
      root = np.inf
      error = np.inf
      iter = 0
      if func.subs(x, a) * func.subs(x, b) > 0:
          print("No existe una raíz en el intervalo proporcionado...")
          #exit(0)
      # Validar valores
      if abs(func.subs(x, a)) < abs(func.subs(x, b)):
          # Cambiar los valores de a por b y viceversa
          a,b = b,a
          
      flag = True
      c = a
      while( abs(a-b) > tol and iter < maxIter):
          if (func.subs(x, a) != func.subs(x, c)) and (func.subs(x, b) != func.subs(x, c)):
              s = (((a*func.subs(x, b) * func.subs(x, c)) / (((func.subs(x, a) - func.subs(x, b))) * (func.subs(x, a)) - func.subs(x, c))) + 
              (((b*func.subs(x, a) * func.subs(x, c)) / (((func.subs(x, b) - func.subs(x, a))) * (func.subs(x, b)) - func.subs(x, c)))) + 
              (((c*func.subs(x, a) * func.subs(x, b)) / (((func.subs(x, c) - func.subs(x, a))) * (func.subs(x, c)) - func.subs(x, b)))))
          else: 
              # Método de la secante
              s = b - (func.subs(x, b)) * ((b-a) / (func.subs(x, b) - func.subs(x, a))) 
          if ((s<((3*a+b)/4) or s>b) or (flag == True and (abs(s - b)) >= (abs(b - c) / 2)) or
                (flag == False and (abs(s - b)) >= (abs(c - d) / 2)) or
                (flag == True and (abs(b - c)) < tol) or
                (flag == False and (abs(c - d)) < tol)):
                s = (a + b) / 2
                flag = True
    
          else:
            flag = False # TODO incluir condicionales y método de la bisección
          
          n=func.subs(x,s)
          d=c
          c=b

          if float(func.subs(x,a))*float(func.subs(x,s))<0:
            b=s
          else:
            a=s
          
          if abs(float(func.subs(x,a)))<(float(func.subs(x,b))):
            a,b=b,a
          
          if abs(func.subs(x, a)) < abs(func.subs(x, b)):
          # Cambiar los valores de a por b y viceversa
            a,b = b,a
          iter+=1
      return b

    def incrementalSearch(self, a, b, func):
        X = np.linspace(a, b, 10000)
        #print("X", X)
        Y = np.zeros_like(X)
        for i in range(len(X)):
            if func.subs(x, X[i])>(-0.005) and func.subs(x, X[i])<(0.005):
                return X[i]

Solv=NumericalMethods()
a=-10
b=10
f="x**3-(8*x)+5"
f=sympify(f)

print("Busqueda ingenua")

inic=time.time()
Y=Solv.incrementalSearch(a,b,f)
fIng=(time.time()-inic)*1000
print("Tiempo: ",fIng, "ms")
print("Valor aproximado búsqueda ingenua: ", Y)
print("Bisección")
inicio=time.time()
SolBi=Solv.bisectionMethod(a,b,0.0001,f)
fBi=(time.time()-inicio)*1000
print("Tiempo: ",fBi, "ms")
print("Valor aproximado método de la bisección: ",float(SolBi))

print("Newton")
inicio=time.time()
SolN=Solv.Newton(2,20,f)
fN=(time.time()-inicio)*1000
print("Tiempo: ",fN, "ms")
print("Valor aproximado método de Newton: ",float(SolN))

print("Secante")
inicio=time.time()
SolS=Solv.Secante(f,a,b,tol=0.0001)
fSec=(time.time()-inicio)*1000
print("Tiempo: ",fSec, "ms")
print("Valor aproximado método de la secante: ",float(SolS))

print("Brent-Decker")
inicio=time.time()
SolBrent=Solv.brentDekkerMethod(a,b,f,maxIter=100,tol=0.0001)
fBrent=(time.time()-inicio)*1000
print("Tiempo: ",fBrent, "ms")
print("Valor aproximado método de Brent-Decker: ",float(SolBrent))

import matplotlib.pyplot as plt
l=[fIng/100, fBi,fN,fSec,fBrent]
x = np.arange(len(l))
ind = np.arange(len(l))
fig,ax = plt.subplots() 
ax.set_title("Comparación entre tiempos de cómputo")
ax.set_xticklabels(["Ingenuo","Bisección","Newton","Secante","Brent"], minor=False)
plt.bar(ind, l, color="green",width=0.5)
ax.set_ylabel('Tiempo(ms)')
ax.set_xlabel('Método')
ax.set_xticks(x)
ax.legend(["Método ingenuo en decisegundos"])
plt.show()